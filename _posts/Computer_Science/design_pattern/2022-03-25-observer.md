---
layout: post
title: observer
description: ''
date: '2022-03-25'
categories: design-pattern
note:
usemathjax:
mermaid: true
---

## Introduction

1. One to many relationship (one observerable to many observers)
2. The state of observerable changed and all observers are notified

## Why?

Some business logic needs to update data according to another objects' status; for example, weather Apps need to update data according to the weather data. The pattern to solve this kind of problem is observer.

## How?

Intuitively, we may just keep asking whether the weather changed and then update it accordingly. However, the results are always lagging. As a result, we implement this pattern to solve the problem, letting weather object to tell the weather Apps that the status changed.

<div class="mermaid">
graph LR
  id1((Observable)) -- push: I changed status --> id2((observers))
  id1((Observable)) -- push: I changed status --> id3((observers))
  id1((Observable)) -- push: I changed status --> ...
</div>

and the UML

<div class="mermaid">
classDiagram
  direction RL
  BaseObservable --> BaseObserver : has many

  BaseObservable : add(observer)
  BaseObservable : remove(observer)
  BaseObservable : notify()

  BaseObserver : update()

  BaseObservable <-- WeatherObservable : is a
  BaseObserver <-- WeatherObserverPhone : is a
  BaseObserver <-- WeatherObserverComputer : is a

  WeatherObservable : add(observer)
  WeatherObservable : remove(observer)
  WeatherObservable : notify()
  WeatherObservable : ...()

  WeatherObserverPhone : update()
  WeatherObserverPhone : ...()

  WeatherObserverComputer : update()
  WeatherObserverComputer : ...()
</div>

## What?

```ruby

```

give an example

## Reference

[Observer Pattern â€“ Design Patterns (ep 2)](https://www.youtube.com/watch?v=_BpmfnqjgzQ&list=PLrhzvIcii6GNjpARdnO4ueTUAVR9eMBpc&index=2)
